<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VocabBoost - Há»c Tá»« vá»±ng Tiáº¿ng Anh C1/C2</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for Flashcard flip effect */
        body {
            font-family: 'Inter', sans-serif;
        }
        .perspective-1000 {
            perspective: 1000px;
        }
        .flashcard-inner {
            transform-style: preserve-3d;
        }
        .flashcard-face {
            -webkit-backface-visibility: hidden; /* For Safari */
            backface-visibility: hidden;
        }
        .rotate-y-180 {
            transform: rotateY(180deg);
        }
        /* Style for highlighted words in newsletter */
        .highlighted-word {
            font-weight: bold;
            text-decoration: underline;
            cursor: pointer;
            position: relative; /* Needed for positioning the pronounce button inside */
            /* Removed padding-right for speaker icon as it's removed */
            display: inline-flex; /* To align icon with text baseline */
            align-items: baseline;
            transition: transform 0.1s ease-out, background-color 0.1s ease-out; /* For click effect */
        }
        /* Specific colors for word levels */
        .highlighted-word.b2-level {
            color: #60A5FA; /* blue-400 */
        }
        .highlighted-word.c1-c2-level {
            color: #F87171; /* red-400 */
        }

        /* Click effect for highlighted words */
        .highlighted-word.clicked-effect {
            animation: wordPulse 0.3s ease-out;
        }

        @keyframes wordPulse {
            0% { transform: scale(1); background-color: transparent; }
            50% { transform: scale(1.05); background-color: rgba(255, 255, 255, 0.1); } /* Subtle background flash */
            100% { transform: scale(1); background-color: transparent; }
        }

        /* Removed .pronounce-btn-inline as the button is removed */

        /* Custom Alert Modal Styles */
        .custom-alert-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0; /* Start hidden */
            visibility: hidden; /* Hide from screen readers */
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .custom-alert-overlay.is-visible {
            opacity: 1;
            visibility: visible;
        }
        .custom-alert-box {
            background-color: #1f2937; /* gray-800 */
            padding: 2rem;
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 400px;
            width: 90%;
            border: 1px solid #4b5563; /* gray-600 */
            transform: scale(0.9); /* Start slightly smaller */
            transition: transform 0.3s ease;
        }
        .custom-alert-overlay.is-visible .custom-alert-box {
            transform: scale(1); /* Scale up when visible */
        }
        .custom-alert-box p {
            color: #d1d5db; /* gray-300 */
            font-size: 1.125rem; /* text-lg */
            margin-bottom: 1.5rem;
        }
        .custom-alert-box button {
            background-color: #8B5CF6; /* purple-500 */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: background-color 0.3s ease;
        }
        .custom-alert-box button:hover {
            background-color: #7c3aed; /* purple-600 */
        }
        /* Pronunciation button style */
        .pronounce-btn {
            background: none;
            border: none;
            color: #a78bfa; /* purple-400 */
            cursor: pointer;
            font-size: 1.5rem;
            margin-left: 0.5rem;
            transition: color 0.2s ease;
        }
        .pronounce-btn:hover {
            color: #c4b5fd; /* purple-300 */
        }

        /* Gradient Hover Effect for Buttons */
        .btn-gradient-hover {
            position: relative;
            z-index: 1;
            overflow: hidden;
        }
        .btn-gradient-hover::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.0) 50%, rgba(255,255,255,0.1) 100%);
            transform: translateX(-100%);
            transition: transform 0.5s ease-out;
            z-index: -1;
        }
        .btn-gradient-hover:hover::before {
            transform: translateX(0%);
        }

        /* Section Transition Styles */
        /* These are for the main sections within the review tab */
        #flashcardListContainer, #flashcardLearningArea, #newsletterListContainer, #newsletterReadingArea {
            /* Use absolute positioning to prevent layout shifts during transitions */
            position: absolute; 
            width: 100%;
            left: 0;
            top: 0;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.5s ease-out, transform 0.5s ease-out;
            pointer-events: none; /* Disable interaction when hidden */
        }
        #flashcardListContainer.is-visible, #flashcardLearningArea.is-visible, #newsletterListContainer.is-visible, #newsletterReadingArea.is-visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto; /* Enable interaction when visible */
            position: static; /* Revert to normal flow when active */
        }

        /* Adjust main content for absolute positioning during transition */
        main {
            position: relative;
            min-height: 500px; /* Ensure main has enough height for content */
        }

        /* Popup for word meaning - Changed to absolute position */
        #wordPopup {
            position: absolute; /* Changed from fixed to absolute */
            z-index: 1001; /* Higher than overlay */
            padding: 0.75rem 1rem; /* Adjusted padding */
            background-color: #6d28d9; /* purple-700 */
            color: white;
            border-radius: 0.5rem; /* Adjusted border-radius */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            border: 1px solid #8B5CF6; /* purple-500 */
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform: translateY(-5px); /* Slight initial offset for transition */
            opacity: 0;
            visibility: hidden;
        }
        #wordPopup.is-visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        /* Loading Spinner Styles */
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #8B5CF6; /* purple-500 */
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-right: 8px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="min-h-screen bg-gray-900 text-white p-4 sm:p-6 lg:p-8">

    <!-- Custom Alert Modal -->
    <div id="customAlertOverlay" class="custom-alert-overlay hidden">
        <div class="custom-alert-box">
            <p id="customAlertMessage"></p>
            <button id="customAlertCloseBtn" class="btn-gradient-hover">ÄÃ³ng</button>
        </div>
    </div>

    <!-- Header -->
    <header class="text-center mb-10">
        <h1 class="text-5xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-600 drop-shadow-lg">
            VocabBoost
        </h1>
        <p class="text-lg text-gray-400 mt-2">NÃ¢ng táº§m tá»« vá»±ng tiáº¿ng Anh C1/C2 cá»§a báº¡n!</p>
    </header>

    <!-- Navigation Tabs -->
    <nav class="mb-8">
        <div class="flex justify-center space-x-4">
            <button id="createTab" class="px-6 py-3 rounded-full text-lg font-semibold transition duration-300 ease-in-out bg-gradient-to-r from-purple-600 to-indigo-600 text-white shadow-lg transform scale-105">
                Táº¡o TÃ i Liá»‡u Há»c
            </button>
            <button id="reviewTab" class="px-6 py-3 rounded-full text-lg font-semibold transition duration-300 ease-in-out bg-gray-700 text-gray-300 hover:bg-gray-600 hover:text-white">
                Ã”n Táº­p & Há»c Táº­p
            </button>
        </div>
    </nav>

    <!-- Main Content Area -->
    <main class="max-w-4xl mx-auto bg-gray-800 p-6 rounded-xl shadow-2xl">

        <!-- Create Materials Section -->
        <section id="create-materials" class="tab-content">
            <h2 class="text-3xl font-bold text-center text-purple-300 mb-8">Táº¡o TÃ i Liá»‡u Há»c</h2>

            <!-- Create Vocabulary & Flashcard Section -->
            <div class="mb-10 p-6 bg-gray-700 rounded-lg shadow-lg">
                <h3 class="text-2xl font-semibold text-white mb-4 border-b border-gray-600 pb-3">1. Táº¡o Bá»™ tá»« vá»±ng & Flashcard</h3>
                <div class="flex flex-col sm:flex-row gap-4 mb-4">
                    <input type="text" id="vocabTopicInput" placeholder="Nháº­p chá»§ Ä‘á» (vÃ­ dá»¥: 'Khoa há»c', 'Kinh táº¿') hoáº·c Ä‘á»ƒ trá»‘ng Ä‘á»ƒ ngáº«u nhiÃªn" class="flex-1 p-3 rounded-md bg-gray-900 text-white border border-gray-600 focus:border-purple-500 focus:ring focus:ring-purple-500 focus:ring-opacity-50 placeholder-gray-500">
                    <button id="generateVocabBtn" class="px-6 py-3 bg-gradient-to-r from-blue-500 to-cyan-500 text-white font-bold rounded-lg shadow-md hover:from-blue-600 hover:to-cyan-600 transition duration-300 transform hover:scale-105 btn-gradient-hover">
                        Táº¡o Tá»« Vá»±ng
                    </button>
                </div>
                <div id="generatedVocabOutput" class="mt-6 p-4 bg-gray-800 rounded-lg shadow-inner">
                    <h3 class="text-xl font-semibold text-white mb-4">Danh sÃ¡ch tá»« vá»±ng Ä‘Ã£ táº¡o:</h3>
                    <p id="vocabLoading" class="text-purple-400 hidden flex items-center justify-center">
                        <span class="loading-spinner"></span> Äang táº¡o tá»« vá»±ng...
                    </p>
                    <p id="vocabError" class="text-red-500 hidden"></p>
                    <ul id="vocabList" class="space-y-3"></ul>
                    <p id="noVocabMessage" class="text-gray-400">ChÆ°a cÃ³ tá»« vá»±ng nÃ o Ä‘Æ°á»£c táº¡o. Nháº­p chá»§ Ä‘á» vÃ  nháº¥n "Táº¡o"!</p>
                    <button id="saveFlashcardsBtn" class="mt-6 w-full py-3 bg-gradient-to-r from-green-500 to-teal-500 text-white font-bold rounded-lg shadow-lg hover:from-green-600 hover:to-teal-600 transition duration-300 transform hover:scale-105 btn-gradient-hover hidden">
                        LÆ°u thÃ nh Bá»™ Flashcard
                    </button>
                </div>
            </div>

            <!-- Create Vocabulary Newsletter Section -->
            <div class="p-6 bg-gray-700 rounded-lg shadow-lg">
                <h3 class="text-2xl font-semibold text-white mb-4 border-b border-gray-600 pb-3">2. Táº¡o Báº£n tin Tá»« vá»±ng</h3>
                <div class="flex flex-col sm:flex-row gap-4 mb-4">
                    <input type="text" id="newsletterTopicInput" placeholder="Nháº­p chá»§ Ä‘á» (vÃ­ dá»¥: 'CÃ´ng nghá»‡', 'MÃ´i trÆ°á»ng') hoáº·c Ä‘á»ƒ trá»‘ng Ä‘á»ƒ ngáº«u nhiÃªn" class="flex-1 p-3 rounded-md bg-gray-900 text-white border border-gray-600 focus:border-purple-500 focus:ring focus:ring-purple-500 focus:ring-opacity-50 placeholder-gray-500">
                    <button id="generateNewsletterBtn" class="px-6 py-3 bg-gradient-to-r from-blue-500 to-cyan-500 text-white font-bold rounded-lg shadow-md hover:from-blue-600 hover:to-cyan-600 transition duration-300 transform hover:scale-105 btn-gradient-hover">
                        Táº¡o Báº£n Tin
                    </button>
                </div>
                <div id="generatedNewsletterOutput" class="mt-6 p-4 bg-gray-800 rounded-lg shadow-inner">
                    <h3 class="text-xl font-semibold text-white mb-4">Báº£n tin Ä‘Ã£ táº¡o:</h3>
                    <p id="newsletterLoading" class="text-purple-400 hidden flex items-center justify-center">
                        <span class="loading-spinner"></span> Äang táº¡o báº£n tin...
                    </p>
                    <p id="newsletterError" class="text-red-500 hidden"></p>
                    <div id="newsletterContent" class="text-gray-300 leading-relaxed text-base bg-gray-700 p-4 rounded-md shadow-sm hidden"></div> <!-- Added 'hidden' class here -->
                    <p id="noNewsletterMessage" class="text-gray-400">ChÆ°a cÃ³ báº£n tin nÃ o Ä‘Æ°á»£c táº¡o. Nháº­p chá»§ Ä‘á» vÃ  nháº¥n "Táº¡o"!</p>
                    <button id="saveNewsletterBtn" class="mt-6 w-full py-3 bg-gradient-to-r from-green-500 to-teal-500 text-white font-bold rounded-lg shadow-lg hover:from-green-600 hover:to-teal-600 transition duration-300 transform hover:scale-105 btn-gradient-hover hidden">
                        LÆ°u Báº£n tin
                    </button>
                </div>
            </div>
        </section>

        <!-- Review & Learn Section -->
        <section id="review-learn" class="tab-content">
            <h2 class="text-3xl font-bold text-center text-purple-300 mb-8">Ã”n Táº­p & Há»c Táº­p</h2>

            <!-- Learn via Flashcards Section -->
            <div class="mb-10 p-6 bg-gray-700 rounded-lg shadow-lg">
                <h3 class="text-2xl font-semibold text-white mb-4 border-b border-gray-600 pb-3">1. Há»c qua Flashcard</h3>
                <div id="flashcardListContainer" class="is-visible"> <!-- Container for flashcard grid -->
                    <div id="savedFlashcardGrid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 mb-4">
                        <!-- Flashcard sets will be rendered here -->
                    </div>
                    <p id="noSavedFlashcardsMessage" class="text-gray-400 text-center">ChÆ°a cÃ³ bá»™ flashcard nÃ o Ä‘Æ°á»£c lÆ°u. HÃ£y táº¡o má»™t bá»™ á»Ÿ tab "Táº¡o TÃ i Liá»‡u Há»c"!</p>
                </div>

                <div id="flashcardLearningArea" class="hidden"> <!-- New: Area for active flashcard learning -->
                    <div id="flashcardDisplay" class="flex flex-col items-center">
                        <!-- Flashcard -->
                        <div id="flashcardContainer" class="flashcard-container w-full max-w-md h-64 perspective-1000 cursor-pointer mb-6">
                            <div id="flashcardInner" class="flashcard-inner relative w-full h-full text-center rounded-xl shadow-xl transition-transform duration-700 ease-in-out">
                                <!-- Front Face -->
                                <div id="flashcardFront" class="flashcard-face flashcard-front absolute w-full h-full bg-gradient-to-br from-purple-700 to-indigo-700 rounded-xl flex items-center justify-center p-4 backface-hidden">
                                    <p id="flashcardWord" class="text-4xl font-bold text-white"></p>
                                    <button id="flashcardPronounceBtn" class="pronounce-btn absolute top-2 right-2" title="Nghe phÃ¡t Ã¢m">
                                        &#128266; <!-- Speaker emoji -->
                                    </button>
                                </div>
                                <!-- Back Face -->
                                <div id="flashcardBack" class="flashcard-face flashcard-back absolute w-full h-full bg-gradient-to-br from-teal-600 to-green-600 rounded-xl flex flex-col items-center justify-center p-4 rotate-y-180 backface-hidden">
                                    <p id="flashcardMeaning" class="text-2xl font-bold text-white mb-2"></p>
                                    <p id="flashcardIPA" class="text-xl italic text-gray-100 mb-2"></p>
                                    <p id="flashcardExample" class="text-lg text-gray-200 text-center"></p>
                                </div>
                            </div>
                        </div>

                        <!-- Flashcard Navigation Buttons -->
                        <div class="flex space-x-4">
                            <button id="prevFlashcardBtn" class="px-6 py-3 bg-gray-600 text-white font-bold rounded-full shadow-md hover:bg-gray-500 transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed btn-gradient-hover">
                                TrÆ°á»›c
                            </button>
                            <button id="nextFlashcardBtn" class="px-6 py-3 bg-gradient-to-r from-purple-500 to-pink-500 text-white font-bold rounded-full shadow-md hover:from-purple-600 hover:to-pink-600 transition duration-300 btn-gradient-hover">
                                Tiáº¿p theo
                            </button>
                        </div>
                        <p id="flashcardCounter" class="mt-4 text-gray-400"></p>
                    </div>
                    <button id="backToFlashcardListBtn" class="mt-6 w-full py-3 bg-gray-600 text-white font-bold rounded-lg shadow-lg hover:bg-gray-500 transition duration-300 transform hover:scale-105 btn-gradient-hover">
                        Quay vá» danh sÃ¡ch Flashcard
                    </button>
                </div>
            </div>

            <!-- Learn via Newsletter Section -->
            <div class="p-6 bg-gray-700 rounded-lg shadow-lg">
                <h3 class="text-2xl font-semibold text-white mb-4 border-b border-gray-600 pb-3">2. Há»c qua Báº£n tin</h3>
                <div id="newsletterListContainer" class="is-visible"> <!-- Container for newsletter grid -->
                    <div id="savedNewsletterGrid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 mb-4">
                        <!-- Newsletters will be rendered here -->
                    </div>
                    <p id="noSavedNewslettersMessage" class="text-gray-400 text-center">ChÆ°a cÃ³ báº£n tin nÃ o Ä‘Æ°á»£c lÆ°u. HÃ£y táº¡o má»™t báº£n tin á»Ÿ tab "Táº¡o TÃ i Liá»‡u Há»c"!</p>
                </div>

                <div id="newsletterReadingArea" class="hidden"> <!-- New: Area for active newsletter reading -->
                    <h4 id="newsletterTitleDisplay" class="text-2xl font-bold text-purple-300 mb-4 flex items-center"></h4>
                    <div id="selectedNewsletterContent" class="text-gray-300 leading-relaxed text-base bg-gray-800 p-4 rounded-md shadow-inner"></div>
                    <p id="noSelectedNewsletterContentMessage" class="text-gray-400 text-center hidden">Vui lÃ²ng chá»n má»™t báº£n tin Ä‘á»ƒ Ä‘á»c vÃ  há»c.</p>
                    <button id="backToNewsletterListBtn" class="mt-6 w-full py-3 bg-gray-600 text-white font-bold rounded-lg shadow-lg hover:bg-gray-500 transition duration-300 transform hover:scale-105 btn-gradient-hover">
                        Quay vá» danh sÃ¡ch Báº£n tin
                    </button>
                </div>
                <!-- Pop-up for word meaning -->
                <div id="wordPopup" class="word-popup p-3 bg-purple-700 text-white rounded-lg shadow-xl border border-purple-500 hidden">
                    <p id="popupMeaning" class="font-bold"></p>
                    <p id="popupPartOfSpeech" class="text-sm italic"></p> <!-- New: for part of speech -->
                    <p id="popupIPA" class="text-sm italic"></p>
                </div>
            </div>
        </section>
    </main>

    <!-- Footer -->
    <footer class="text-center text-gray-500 mt-10 text-sm">
        <p>&copy; 2025 VocabBoost. Báº£o lÆ°u má»i quyá»n.</p>
    </footer>

    <script>
        // Global variables for application state
        let activeTab = 'create';
        let generatedVocab = [];
        let generatedNewsletterHtml = ''; // Stores the processed HTML string for newsletter
        let savedFlashcards = [];
        let savedNewsletters = [];

        let currentFlashcardIndex = 0;
        let isFlipped = false;
        let shuffledFlashcards = [];
        let activeFlashcardSetId = null; // Changed from selectedFlashcardSet for clarity
        let activeNewsletterId = null; // New state for active newsletter

        // DOM elements
        const createTabBtn = document.getElementById('createTab');
        const reviewTabBtn = document.getElementById('reviewTab');
        const createMaterialsSection = document.getElementById('create-materials');
        const reviewLearnSection = document.getElementById('review-learn');

        const vocabTopicInput = document.getElementById('vocabTopicInput');
        const generateVocabBtn = document.getElementById('generateVocabBtn');
        const vocabLoading = document.getElementById('vocabLoading');
        const vocabError = document.getElementById('vocabError');
        const vocabList = document.getElementById('vocabList');
        const noVocabMessage = document.getElementById('noVocabMessage');
        const saveFlashcardsBtn = document.getElementById('saveFlashcardsBtn');

        const newsletterTopicInput = document.getElementById('newsletterTopicInput');
        const generateNewsletterBtn = document.getElementById('generateNewsletterBtn');
        const newsletterLoading = document.getElementById('newsletterLoading');
        const newsletterError = document.getElementById('newsletterError');
        const newsletterContentDiv = document.getElementById('newsletterContent'); // For create tab
        const noNewsletterMessage = document.getElementById('noNewsletterMessage');
        const saveNewsletterBtn = document.getElementById('saveNewsletterBtn');

        const flashcardListContainer = document.getElementById('flashcardListContainer'); // New container for flashcard grid
        const savedFlashcardGrid = document.getElementById('savedFlashcardGrid'); // New DOM element
        const noSavedFlashcardsMessage = document.getElementById('noSavedFlashcardsMessage'); // New DOM element
        const flashcardLearningArea = document.getElementById('flashcardLearningArea'); // New: Area for active flashcard learning
        const flashcardDisplay = document.getElementById('flashcardDisplay');
        const flashcardContainer = document.getElementById('flashcardContainer');
        const flashcardInner = document.getElementById('flashcardInner');
        const flashcardWord = document.getElementById('flashcardWord');
        const flashcardMeaning = document.getElementById('flashcardMeaning');
        const flashcardIPA = document.getElementById('flashcardIPA');
        const flashcardExample = document.getElementById('flashcardExample');
        const prevFlashcardBtn = document.getElementById('prevFlashcardBtn');
        const nextFlashcardBtn = document.getElementById('nextFlashcardBtn');
        const flashcardCounter = document.getElementById('flashcardCounter');
        const flashcardPronounceBtn = document.getElementById('flashcardPronounceBtn'); // New: Pronounce button for flashcard
        const backToFlashcardListBtn = document.getElementById('backToFlashcardListBtn'); // New: Back button

        const newsletterListContainer = document.getElementById('newsletterListContainer'); // New container for newsletter grid
        const savedNewsletterGrid = document.getElementById('savedNewsletterGrid'); // New DOM element
        const noSavedNewslettersMessage = document.getElementById('noSavedNewslettersMessage'); // New DOM element
        const newsletterReadingArea = document.getElementById('newsletterReadingArea'); // New: Area for active newsletter reading
        const newsletterTitleDisplay = document.getElementById('newsletterTitleDisplay'); // New: for displaying newsletter title
        const selectedNewsletterContent = document.getElementById('selectedNewsletterContent'); // For review tab
        const noSelectedNewsletterContentMessage = document.getElementById('noSelectedNewsletterContentMessage'); // Changed message ID
        const backToNewsletterListBtn = document.getElementById('backToNewsletterListBtn'); // New: Back button
        const wordPopup = document.getElementById('wordPopup');
        const popupMeaning = document.getElementById('popupMeaning');
        const popupIPA = document.getElementById('popupIPA');
        const popupPartOfSpeech = document.getElementById('popupPartOfSpeech'); // New: DOM element for part of speech

        // Custom Alert DOM elements
        const customAlertOverlay = document.getElementById('customAlertOverlay');
        const customAlertMessage = document.getElementById('customAlertMessage');
        const customAlertCloseBtn = document.getElementById('customAlertCloseBtn');

        // Reference to the main content area for positioning calculations
        const main = document.querySelector('main'); 

        // --- Utility Functions ---

        // Show custom alert
        function showCustomAlert(message) {
            customAlertMessage.textContent = message;
            customAlertOverlay.classList.remove('hidden');
            customAlertOverlay.classList.add('is-visible');
        }

        // Hide custom alert
        customAlertCloseBtn.addEventListener('click', () => {
            customAlertOverlay.classList.remove('is-visible');
            // Add a small delay for the transition to complete before hiding fully
            setTimeout(() => {
                customAlertOverlay.classList.add('hidden');
            }, 300); 
        });

        // Load data from localStorage on page load
        document.addEventListener('DOMContentLoaded', () => {
            savedFlashcards = JSON.parse(localStorage.getItem('vocabBoostFlashcards')) || [];
            savedNewsletters = JSON.parse(localStorage.getItem('vocabBoostNewsletters')) || [];
            renderSavedFlashcards(); // Render cards instead of select
            renderSavedNewsletters(); // Render cards instead of select
            showTab(activeTab); // Show the initial tab
        });

        // Save data to localStorage
        function saveData(key, data) {
            localStorage.setItem(key, JSON.stringify(data));
        }

        // --- Pronunciation Function ---
        function speakWord(word, lang = 'en-US') {
            if ('speechSynthesis' in window) {
                // Cancel any ongoing speech
                speechSynthesis.cancel(); 
                const utterance = new SpeechSynthesisUtterance(word);
                utterance.lang = lang;
                speechSynthesis.speak(utterance);
            } else {
                showCustomAlert('TrÃ¬nh duyá»‡t cá»§a báº¡n khÃ´ng há»— trá»£ phÃ¡t Ã¢m.');
            }
        }

        // --- Check for duplicate words in saved data (flashcards and newsletters) ---
        // This function is only used for generating NEW flashcards to avoid adding duplicates to saved sets.
        // It is NOT used for highlighting words within newsletters.
        function isDuplicateWordInSavedData(wordToCheck) {
            const lowerCaseWord = wordToCheck.toLowerCase();

            // Check in saved flashcards
            const flashcardWords = savedFlashcards.flatMap(set => set.words.map(w => w.word.toLowerCase()));
            if (flashcardWords.includes(lowerCaseWord)) {
                return true;
            }

            // Check in saved newsletters (extract highlighted words)
            const newsletterWords = savedNewsletters.flatMap(nl => {
                const doc = new DOMParser().parseFromString(nl.content, 'text/html');
                const highlightedSpans = doc.querySelectorAll('.highlighted-word');
                return Array.from(highlightedSpans).map(span => {
                    // Extract only the text content, excluding the inline pronounce button
                    const tempSpan = document.createElement('span');
                    tempSpan.innerHTML = span.innerHTML;
                    // The inline pronounce button is no longer there, but keeping this for robustness if structure changes
                    // const btn = tempSpan.querySelector('.pronounce-btn-inline');
                    // if (btn) btn.remove();
                    return tempSpan.textContent.toLowerCase();
                });
            });
            if (newsletterWords.includes(lowerCaseWord)) {
                return true;
            }

            return false;
        }

        // Show/hide tabs
        function showTab(tabId) {
            activeTab = tabId;
            if (tabId === 'create') {
                createMaterialsSection.classList.remove('hidden');
                reviewLearnSection.classList.add('hidden');
                createTabBtn.classList.add('bg-gradient-to-r', 'from-purple-600', 'to-indigo-600', 'text-white', 'shadow-lg', 'transform', 'scale-105');
                createTabBtn.classList.remove('bg-gray-700', 'text-gray-300', 'hover:bg-gray-600', 'hover:text-white');
                reviewTabBtn.classList.remove('bg-gradient-to-r', 'from-purple-600', 'to-indigo-600', 'text-white', 'shadow-lg', 'transform', 'scale-105');
                reviewTabBtn.classList.add('bg-gray-700', 'text-gray-300', 'hover:bg-gray-600', 'hover:text-white');
            } else {
                createMaterialsSection.classList.add('hidden');
                reviewLearnSection.classList.remove('hidden');
                reviewTabBtn.classList.add('bg-gradient-to-r', 'from-purple-600', 'to-indigo-600', 'text-white', 'shadow-lg', 'transform', 'scale-105');
                reviewTabBtn.classList.remove('bg-gray-700', 'text-gray-300', 'hover:bg-gray-600', 'hover:text-white');
                createTabBtn.classList.remove('bg-gradient-to-r', 'from-purple-600', 'to-indigo-600', 'text-white', 'shadow-lg', 'transform', 'scale-105');
                createTabBtn.classList.add('bg-gray-700', 'text-gray-300', 'hover:bg-gray-600', 'hover:text-white');

                // When switching to review tab, ensure both lists are visible and learning areas are hidden
                flashcardListContainer.classList.remove('hidden');
                flashcardListContainer.classList.add('is-visible');
                flashcardLearningArea.classList.add('hidden');
                flashcardLearningArea.classList.remove('is-visible');

                newsletterListContainer.classList.remove('hidden');
                newsletterListContainer.classList.add('is-visible');
                newsletterReadingArea.classList.add('hidden');
                newsletterReadingArea.classList.remove('is-visible');
            }
        }

        // --- Gemini API Call Function ---
        async function callGeminiAPI(prompt, schema = null) {
            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });

            const payload = { contents: chatHistory };
            if (schema) {
                payload.generationConfig = {
                    responseMimeType: "application/json",
                    responseSchema: schema
                };
            }

            // API Key cá»§a báº¡n
            const apiKey = "AIzaSyDe33qK44IF_aCXQEOwGqDCZ5iQCN9I5Qg"; 
            // Sá»­ dá»¥ng mÃ´ hÃ¬nh gemini-2.5-flash
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    return schema ? JSON.parse(text) : text;
                } else {
                    console.error("Unexpected API response structure:", result);
                    throw new Error("KhÃ´ng thá»ƒ táº¡o ná»™i dung. Vui lÃ²ng thá»­ láº¡i.");
                }
            } catch (error) {
                console.error("Error calling Gemini API:", error);
                throw new Error(`Lá»—i API: ${error.message}`);
            }
        }

        // --- Generate Vocabulary Function ---
        generateVocabBtn.addEventListener('click', async () => {
            vocabLoading.classList.remove('hidden');
            vocabError.classList.add('hidden');
            vocabList.innerHTML = '';
            noVocabMessage.classList.add('hidden');
            saveFlashcardsBtn.classList.add('hidden');
            generateVocabBtn.disabled = true;

            const vocabTopic = vocabTopicInput.value.trim();
            const targetWordCount = 10;
            let currentGeneratedWordsForSession = []; // Tracks words generated in *this session* (multiple clicks)
            
            const schema = {
                type: "ARRAY",
                items: {
                    type: "OBJECT",
                    properties: {
                        "word": { "type": "STRING" },
                        "meaning": { "type": "STRING" },
                        "ipa": { "type": "STRING" },
                        "example": { "type": "STRING" },
                        "partOfSpeech": { "type": "STRING" } // New: Added partOfSpeech
                    },
                    "propertyOrdering": ["word", "meaning", "ipa", "example", "partOfSpeech"] // New: Added partOfSpeech
                }
            };

            try {
                for (let attempt = 0; attempt < 5; attempt++) { // Max 5 attempts to get all words
                    const wordsNeeded = targetWordCount - currentGeneratedWordsForSession.length;
                    if (wordsNeeded <= 0) {
                        break; // Already have enough words
                    }

                    const requestCount = wordsNeeded + 3; // Request a few more than needed to account for potential duplicates
                    
                    // Construct the negative constraint for the prompt based on words already collected in this session
                    const wordsToExcludeFromLLM = currentGeneratedWordsForSession.map(w => `"${w.word}"`).join(', ');
                    const exclusionPrompt = wordsToExcludeFromLLM ? `KhÃ´ng Ä‘Æ°á»£c trÃ¹ng láº·p vá»›i cÃ¡c tá»« sau: ${wordsToExcludeFromLLM}. ` : '';

                    // Updated prompt to explicitly state partOfSpeech is mandatory and in short form
                    const prompt = `Táº¡o má»™t danh sÃ¡ch ${requestCount} tá»« vá»±ng tiáº¿ng Anh trÃ¬nh Ä‘á»™ C1/C2 ${vocabTopic ? `liÃªn quan Ä‘áº¿n chá»§ Ä‘á» "${vocabTopic}"` : 'ngáº«u nhiÃªn'}. ${exclusionPrompt}Vá»›i má»—i tá»«, cung cáº¥p nghÄ©a tiáº¿ng Viá»‡t, phiÃªn Ã¢m IPA, loáº¡i tá»« (báº¯t buá»™c, dáº¡ng viáº¿t táº¯t nhÆ° "n.", "v.", "adj."), vÃ  má»™t cÃ¢u vÃ­ dá»¥. Äá»‹nh dáº¡ng JSON nhÆ° sau:
                    [
                      {
                        "word": "Tá»« vá»±ng",
                        "meaning": "NghÄ©a tiáº¿ng Viá»‡t",
                        "ipa": "PhiÃªn Ã¢m IPA",
                        "example": "CÃ¢u vÃ­ dá»¥",
                        "partOfSpeech": "Loáº¡i tá»« (vd: n., v., adj.)"
                      }
                    ]
                    `;

                    const data = await callGeminiAPI(prompt, schema);
                    
                    for (const item of data) {
                        if (currentGeneratedWordsForSession.length >= targetWordCount) {
                            break; // Stop if target reached during this batch
                        }
                        // Check against words already collected in *this session* AND against *saved* words
                        const isAlreadyInSession = currentGeneratedWordsForSession.some(w => w.word.toLowerCase() === item.word.toLowerCase());
                        const isAlreadySaved = isDuplicateWordInSavedData(item.word);

                        if (!isAlreadyInSession && !isAlreadySaved) {
                            currentGeneratedWordsForSession.push(item);
                        }
                    }

                    if (currentGeneratedWordsForSession.length === targetWordCount) {
                        break;
                    }
                }

                generatedVocab = currentGeneratedWordsForSession; // Assign the collected words to the global variable
                renderGeneratedVocab();

                if (generatedVocab.length < targetWordCount) {
                    vocabError.textContent = `Chá»‰ táº¡o Ä‘Æ°á»£c ${generatedVocab.length} tá»«. Má»™t sá»‘ tá»« bá»‹ trÃ¹ng láº·p hoáº·c khÃ´ng thá»ƒ táº¡o thÃªm. Vui lÃ²ng thá»­ láº¡i vá»›i chá»§ Ä‘á» khÃ¡c hoáº·c Ä‘á»ƒ trá»‘ng.`;
                    vocabError.classList.remove('hidden');
                } else {
                    vocabError.classList.add('hidden');
                }

            } catch (error) {
                vocabError.textContent = error.message;
                vocabError.classList.remove('hidden');
            } finally {
                vocabLoading.classList.add('hidden');
                generateVocabBtn.disabled = false;
            }
        });

        // Function to remove a vocabulary word from the generated list
        function removeVocabWord(index) {
            generatedVocab.splice(index, 1); // Remove word from array
            renderGeneratedVocab(); // Re-render the list
            showCustomAlert('ÄÃ£ xÃ³a tá»« vá»±ng.');
        }

        function renderGeneratedVocab() {
            vocabList.innerHTML = '';
            if (generatedVocab.length > 0) {
                generatedVocab.forEach((item, index) => {
                    const li = document.createElement('li');
                    li.className = 'flex flex-col md:flex-row items-start md:items-center p-3 bg-gray-700 rounded-md shadow-sm';
                    // Add fallback for partOfSpeech if it's empty or undefined
                    const partOfSpeechDisplay = item.partOfSpeech ? `(${item.partOfSpeech})` : '';
                    li.innerHTML = `
                        <div class="flex-1">
                            <p class="text-lg font-medium text-purple-300">${item.word} 
                                <button class="pronounce-btn" data-word="${item.word}" title="Nghe phÃ¡t Ã¢m">&#128266;</button>
                            </p>
                            <p class="text-gray-300 text-sm italic">${partOfSpeechDisplay} - ${item.meaning} - ${item.ipa}</p>
                            <p class="text-gray-400 text-sm">"${item.example}"</p>
                        </div>
                        <button class="delete-vocab-btn ml-4 px-3 py-1 bg-red-600 text-white rounded-md hover:bg-red-700 transition duration-200 btn-gradient-hover" data-index="${index}">XÃ³a</button>
                    `;
                    vocabList.appendChild(li);
                });
                // Attach event listeners to delete buttons
                document.querySelectorAll('.delete-vocab-btn').forEach(button => {
                    button.addEventListener('click', (event) => {
                        const index = parseInt(event.target.dataset.index);
                        removeVocabWord(index);
                    });
                });
                // Attach event listeners to pronounce buttons
                document.querySelectorAll('.pronounce-btn').forEach(button => {
                    button.addEventListener('click', (event) => {
                        const wordToSpeak = event.target.dataset.word;
                        speakWord(wordToSpeak);
                    });
                });
                saveFlashcardsBtn.classList.remove('hidden');
            } else {
                noVocabMessage.classList.remove('hidden');
                saveFlashcardsBtn.classList.add('hidden');
            }
        }

        // --- Generate Newsletter Function ---
        generateNewsletterBtn.addEventListener('click', async () => {
            newsletterLoading.classList.remove('hidden');
            newsletterError.classList.add('hidden');
            newsletterContentDiv.innerHTML = '';
            noNewsletterMessage.classList.add('hidden');
            saveNewsletterBtn.classList.add('hidden');
            generateNewsletterBtn.disabled = true;

            const newsletterTopic = newsletterTopicInput.value.trim();
            const defaultNewsletterTitle = newsletterTopic || `Báº£n tin ngáº«u nhiÃªn ${new Date().toLocaleDateString('vi-VN')}`;
            const newsletterIcon = getNewsletterIcon(newsletterTopic); // Get icon based on topic

            const schema = {
                type: "OBJECT",
                properties: {
                    "newsletter_content": { "type": "STRING" },
                    "vocabulary": {
                        "type": "ARRAY",
                        "items": {
                            "type": "OBJECT",
                            "properties": {
                                "word": { "type": "STRING" },
                                "meaning": { "type": "STRING" },
                                "ipa": { "type": "STRING" },
                                "level": { "type": "STRING", "enum": ["B2", "C1/C2"] },
                                "partOfSpeech": { "type": "STRING" } // New: Added partOfSpeech
                            },
                            "propertyOrdering": ["word", "meaning", "ipa", "level", "partOfSpeech"] // New: Added partOfSpeech
                        }
                    }
                }
            };

            // Collect all highlighted words from saved newsletters to use as a soft exclusion list for AI
            const wordsToExcludeFromNewsletterLLM = savedNewsletters.flatMap(nl => {
                const doc = new DOMParser().parseFromString(nl.content, 'text/html');
                const highlightedSpans = doc.querySelectorAll('.highlighted-word');
                return Array.from(highlightedSpans).map(span => {
                    const tempSpan = document.createElement('span');
                    tempSpan.innerHTML = span.innerHTML;
                    return `"${tempSpan.textContent}"`; // Get the actual word text
                });
            }).join(', ');

            const exclusionPromptForNewsletter = wordsToExcludeFromNewsletterLLM ? `Háº¡n cháº¿ sá»­ dá»¥ng cÃ¡c tá»« sau: ${wordsToExcludeFromNewsletterLLM}. ` : '';


            // Updated prompt to explicitly state partOfSpeech is mandatory and in short form
            const prompt = `Viáº¿t má»™t báº£n tin ngáº¯n báº±ng tiáº¿ng Anh (khoáº£ng 150-200 tá»«) ${newsletterTopic ? `vá» chá»§ Ä‘á» "${newsletterTopic}"` : 'ngáº«u nhiÃªn'}. ${exclusionPromptForNewsletter}Sau Ä‘Ã³, liá»‡t kÃª táº¥t cáº£ cÃ¡c tá»« vá»±ng trÃ¬nh Ä‘á»™ B2, C1, C2 trong báº£n tin Ä‘Ã³, kÃ¨m theo nghÄ©a tiáº¿ng Viá»‡t, phiÃªn Ã¢m IPA, loáº¡i tá»« (báº¯t buá»™c, dáº¡ng viáº¿t táº¯t nhÆ° "n.", "v.", "adj."), vÃ  cáº¥p Ä‘á»™ (B2 hoáº·c C1/C2). Tráº£ vá» dÆ°á»›i dáº¡ng JSON vá»›i hai trÆ°á»ng: 'newsletter_content' (ná»™i dung báº£n tin thÃ´, sá»­ dá»¥ng \\n\\n cho cÃ¡c Ä‘oáº¡n vÄƒn) vÃ  'vocabulary' (má»™t máº£ng cÃ¡c Ä‘á»‘i tÆ°á»£ng tá»« vá»±ng).
            VÃ­ dá»¥ JSON:
            {
              "newsletter_content": "The ubiquitous nature of technology has transformed our daily lives.\\n\\nThis transformation is evident in various sectors...",
              "vocabulary": [
                {
                  "word": "ubiquitous",
                  "meaning": "phá»• biáº¿n",
                  "ipa": "/juËËˆbÉªkwitÉ™s/",
                  "level": "C1/C2",
                  "partOfSpeech": "adj."
                },
                {
                  "word": "transform",
                  "meaning": "biáº¿n Ä‘á»•i",
                  "ipa": "/trÃ¦nsËˆfÉ”Ërm/",
                  "level": "B2",
                  "partOfSpeech": "v."
                }
              ]
            }
            `;

            try {
                const data = await callGeminiAPI(prompt, schema);
                let newsletterText = data.newsletter_content;
                const vocabularyWords = data.vocabulary;

                // Process newsletterText for paragraph breaks
                newsletterText = newsletterText.split('\n\n').map(p => `<p class="mb-4">${p.trim()}</p>`).join('');

                // Set to track words that have already been highlighted in this specific newsletter generation
                const wordsHighlightedInCurrentNewsletter = new Set();

                // Sort words by length in descending order to avoid issues with substrings (e.g., "carbon" before "decarbonization")
                vocabularyWords.sort((a, b) => b.word.length - a.word.length);

                for (const item of vocabularyWords) {
                    const cleanWord = item.word;
                    const lowerCaseCleanWord = cleanWord.toLowerCase();

                    // Only highlight if this word has NOT already been highlighted in *this specific newsletter generation*.
                    if (wordsHighlightedInCurrentNewsletter.has(lowerCaseCleanWord)) {
                        continue; // Skip if already highlighted in this newsletter
                    }

                    const levelClass = item.level === 'B2' ? 'b2-level' : 'c1-c2-level';
                    // Added fallback for partOfSpeech in data-attribute
                    const partOfSpeechAttr = item.partOfSpeech ? item.partOfSpeech : '';
                    const replacementHtml = `<span class="highlighted-word ${levelClass}" data-meaning="${item.meaning}" data-ipa="${item.ipa}" data-part-of-speech="${partOfSpeechAttr}">${cleanWord}</span>`; 

                    // Find the first occurrence of the word in the current newsletterText
                    // Use a regex with word boundaries to ensure whole word matching
                    // No 'g' flag to ensure only the first match is replaced
                    const regex = new RegExp(`\\b${cleanWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i'); 

                    // Replace only the first occurrence
                    if (newsletterText.match(regex)) { // Check if word exists before attempting to replace
                        newsletterText = newsletterText.replace(regex, replacementHtml);
                        wordsHighlightedInCurrentNewsletter.add(lowerCaseCleanWord); // Mark as highlighted for this newsletter
                    }
                }
                
                // Add expressive icons to the newsletter content
                generatedNewsletterHtml = addExpressiveIconsToNewsletter(newsletterText, newsletterTopic);

                // Store title and icon along with content
                newsletterContentDiv.dataset.title = defaultNewsletterTitle;
                newsletterContentDiv.dataset.icon = newsletterIcon;

                renderGeneratedNewsletter();
            } catch (error) {
                newsletterError.textContent = error.message;
                newsletterError.classList.remove('hidden');
            } finally {
                newsletterLoading.classList.add('hidden');
                generateNewsletterBtn.disabled = false;
            }
        });

        // New function to add expressive icons
        function addExpressiveIconsToNewsletter(htmlContent, topic) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlContent, 'text/html');
            const paragraphs = doc.querySelectorAll('p');

            const topicEmojis = {
                'cÃ´ng nghá»‡': ['ğŸ’»', 'ğŸ¤–', 'ğŸ’¡', 'ğŸ“¡'],
                'technology': ['ğŸ’»', 'ğŸ¤–', 'ğŸ’¡', 'ğŸ“¡'],
                'mÃ´i trÆ°á»ng': ['ğŸŒ³', 'ğŸŒ', 'â™»ï¸', 'ğŸŒ±', 'ğŸ’§'],
                'environment': ['ğŸŒ³', 'ğŸŒ', 'â™»ï¸', 'ğŸŒ±', 'ğŸ’§'],
                'kinh táº¿': ['ğŸ“ˆ', 'ğŸ’°', 'ğŸ“Š', 'ğŸ’¼', 'ğŸ¦'],
                'economy': ['ğŸ“ˆ', 'ğŸ’°', 'ğŸ“Š', 'ğŸ’¼', 'ğŸ¦'],
                'khoa há»c': ['ğŸ”¬', 'ğŸ§ª', 'ğŸ”­', 'ğŸ§¬', 'âš›ï¸'],
                'science': ['ğŸ”¬', 'ğŸ§ª', 'ğŸ”­', 'ğŸ§¬', 'âš›ï¸'],
                'y táº¿': ['ğŸ¥', 'ğŸ’Š', 'ğŸ©º', 'â¤ï¸', 'ğŸ©¹'],
                'health': ['ğŸ¥', 'ğŸ’Š', 'ğŸ©º', 'â¤ï¸', 'ğŸ©¹'],
                'giÃ¡o dá»¥c': ['ğŸ“š', 'ğŸ“', 'âœï¸', 'ğŸ«', 'ğŸ§ '],
                'education': ['ğŸ“š', 'ğŸ“', 'âœï¸', 'ğŸ«', 'ğŸ§ '],
                'nghá»‡ thuáº­t': ['ğŸ¨', 'ğŸ­', 'ğŸ¶', 'ğŸ¬', 'ğŸ–¼ï¸'],
                'art': ['ğŸ¨', 'ğŸ­', 'ğŸ¶', 'ğŸ¬', 'ğŸ–¼ï¸'],
                'du lá»‹ch': ['âœˆï¸', 'ğŸ—ºï¸', 'ğŸ“¸', 'ğŸ–ï¸', 'â›°ï¸'],
                'travel': ['âœˆï¸', 'ğŸ—ºï¸', 'ğŸ“¸', 'ğŸ–ï¸', 'â›°ï¸'],
                'xÃ£ há»™i': ['ğŸ¤', 'ğŸ§‘â€ğŸ¤â€ğŸ§‘', 'ğŸŒ', 'ğŸ—£ï¸', 'ğŸ«‚'],
                'society': ['ğŸ¤', 'ğŸ§‘â€ğŸ¤â€ğŸ§‘', 'ğŸŒ', 'ğŸ—£ï¸', 'ğŸ«‚'],
                'general': ['âœ¨', 'ğŸŒŸ', 'ğŸ’¡', 'ğŸš€', 'ğŸŒˆ', 'ğŸ‰', 'ğŸ’¬', 'âœï¸'] // General fallback emojis
            };

            const lowerTopic = topic.toLowerCase();
            let emojis = topicEmojis['general'];
            for (const key in topicEmojis) {
                if (lowerTopic.includes(key)) {
                    emojis = topicEmojis[key];
                    break;
                }
            }

            paragraphs.forEach((p, index) => {
                // Only add icons to paragraphs that have content and are not just empty
                if (p.textContent.trim().length > 0) {
                    // Get a random emoji from the selected list
                    const randomEmoji = emojis[Math.floor(Math.random() * emojis.length)];
                    
                    // Create a span for the emoji to give it some margin
                    const emojiSpan = doc.createElement('span');
                    emojiSpan.textContent = randomEmoji;
                    emojiSpan.style.marginRight = '0.5rem'; // Add some space after the emoji
                    emojiSpan.style.verticalAlign = 'middle'; // Align with text baseline

                    // Insert the emoji at the beginning of the paragraph
                    p.prepend(emojiSpan);
                }
            });

            return doc.body.innerHTML;
        }

        function renderGeneratedNewsletter() {
            if (generatedNewsletterHtml) {
                newsletterContentDiv.innerHTML = generatedNewsletterHtml;
                newsletterContentDiv.classList.remove('hidden');
                noNewsletterMessage.classList.add('hidden');
                saveNewsletterBtn.classList.remove('hidden');
                // No need to attach event listeners to inline pronounce buttons as they are removed.
                // The main click listener on selectedNewsletterContent (or newsletterContentDiv) will handle pronunciation.
            } else {
                newsletterContentDiv.innerHTML = '';
                newsletterContentDiv.classList.add('hidden');
                noNewsletterMessage.classList.remove('hidden');
                saveNewsletterBtn.classList.add('hidden');
            }
        }

        // Function to get a lively icon based on topic
        function getNewsletterIcon(topic) {
            const lowerTopic = topic.toLowerCase();
            if (lowerTopic.includes('cÃ´ng nghá»‡') || lowerTopic.includes('technology')) return 'ğŸ’»';
            if (lowerTopic.includes('mÃ´i trÆ°á»ng') || lowerTopic.includes('environment') || lowerTopic.includes('green living')) return 'ğŸŒ³';
            if (lowerTopic.includes('kinh táº¿') || lowerTopic.includes('economy')) return 'ğŸ“ˆ';
            if (lowerTopic.includes('khoa há»c') || lowerTopic.includes('science')) return 'ğŸ”¬';
            if (lowerTopic.includes('y táº¿') || lowerTopic.includes('health')) return 'ğŸ¥';
            if (lowerTopic.includes('giÃ¡o dá»¥c') || lowerTopic.includes('education')) return 'ğŸ“š';
            if (lowerTopic.includes('nghá»‡ thuáº­t') || lowerTopic.includes('art')) return 'ğŸ¨';
            if (lowerTopic.includes('du lá»‹ch') || lowerTopic.includes('travel')) return 'âœˆï¸';
            if (lowerTopic.includes('xÃ£ há»™i') || lowerTopic.includes('society')) return 'ğŸ¤';
            return 'ğŸ“°'; // Default icon for general news
        }

        // --- Save Data Functions ---
        saveFlashcardsBtn.addEventListener('click', () => {
            if (generatedVocab.length === 0) {
                showCustomAlert('KhÃ´ng cÃ³ tá»« vá»±ng nÃ o Ä‘á»ƒ lÆ°u.');
                return;
            }
            const newSet = {
                id: Date.now(),
                name: vocabTopicInput.value.trim() || `Bá»™ tá»« vá»±ng ngáº«u nhiÃªn ${new Date().toLocaleDateString('vi-VN')}`,
                words: generatedVocab
            };
            savedFlashcards.push(newSet);
            saveData('vocabBoostFlashcards', savedFlashcards);
            generatedVocab = []; // Clear generated vocab after saving
            vocabTopicInput.value = '';
            renderGeneratedVocab(); // Re-render to clear display
            renderSavedFlashcards(); // Re-render saved flashcard grid
            showCustomAlert('Bá»™ flashcard Ä‘Ã£ Ä‘Æ°á»£c lÆ°u thÃ nh cÃ´ng!');
        });

        saveNewsletterBtn.addEventListener('click', () => {
            if (!generatedNewsletterHtml) {
                showCustomAlert('KhÃ´ng cÃ³ báº£n tin nÃ o Ä‘á»ƒ lÆ°u.');
                return;
            }
            const newNewsletter = {
                id: Date.now(),
                name: newsletterContentDiv.dataset.title, // Use the title generated
                icon: newsletterContentDiv.dataset.icon, // Use the icon generated
                content: generatedNewsletterHtml
            };
            savedNewsletters.push(newNewsletter);
            saveData('vocabBoostNewsletters', savedNewsletters);
            generatedNewsletterHtml = ''; // Clear generated newsletter after saving
            newsletterTopicInput.value = '';
            renderGeneratedNewsletter(); // Re-render to clear display
            renderSavedNewsletters(); // Re-render saved newsletter grid
            showCustomAlert('Báº£n tin Ä‘Ã£ Ä‘Æ°á»£c lÆ°u thÃ nh cÃ´ng!');
        });

        // --- Flashcard Learning Functions (Card View) ---

        // Function to delete a saved flashcard set
        function deleteFlashcardSet(setId) {
            savedFlashcards = savedFlashcards.filter(set => set.id !== setId);
            saveData('vocabBoostFlashcards', savedFlashcards);
            renderSavedFlashcards(); // Re-render the grid
            if (activeFlashcardSetId === setId) {
                resetFlashcardDisplay(); // Reset display if the active set was deleted
            }
            showCustomAlert('ÄÃ£ xÃ³a bá»™ flashcard.');
        }

        // Function to start learning a flashcard set
        function learnFlashcardSet(setId) {
            const set = savedFlashcards.find(s => s.id === setId);
            if (set) {
                shuffledFlashcards = [...set.words].sort(() => Math.random() - 0.5);
                currentFlashcardIndex = 0;
                isFlipped = false;
                activeFlashcardSetId = setId; // Set the active set
                
                // Ensure flashcardDisplay is visible
                flashcardDisplay.classList.remove('hidden'); 
                updateFlashcardDisplay();
                
                // Hide newsletter sections if they are visible
                newsletterListContainer.classList.remove('is-visible');
                newsletterListContainer.classList.add('hidden');
                newsletterReadingArea.classList.remove('is-visible');
                newsletterReadingArea.classList.add('hidden');

                flashcardListContainer.classList.remove('is-visible');
                flashcardListContainer.classList.add('hidden'); // Hide the list of sets immediately after transition starts
                
                setTimeout(() => {
                    flashcardLearningArea.classList.remove('hidden');
                    flashcardLearningArea.classList.add('is-visible'); // Show the learning area with transition
                }, 500); // Delay matches transition duration
            }
        }

        // Function to go back to the flashcard list
        backToFlashcardListBtn.addEventListener('click', () => {
            flashcardLearningArea.classList.remove('is-visible');
            flashcardLearningArea.classList.add('hidden'); // Hide the learning area immediately after transition starts
            
            setTimeout(() => {
                renderSavedFlashcards(); // Re-render flashcard list
                renderSavedNewsletters(); // Re-render newsletter list to ensure it's visible
                resetFlashcardDisplay(); // Reset display state
            }, 500); // Delay matches transition duration
        });


        function renderSavedFlashcards() {
            savedFlashcardGrid.innerHTML = ''; // Clear current grid
            // Always ensure the list container is visible when this function is called
            flashcardListContainer.classList.remove('hidden');
            flashcardListContainer.classList.add('is-visible');
            // Always ensure the learning area is hidden
            flashcardLearningArea.classList.add('hidden');
            flashcardLearningArea.classList.remove('is-visible');

            if (savedFlashcards.length > 0) {
                noSavedFlashcardsMessage.classList.add('hidden');
                savedFlashcards.forEach(set => {
                    const card = document.createElement('div');
                    card.className = 'bg-gray-800 p-4 rounded-lg shadow-md flex flex-col justify-between';
                    card.innerHTML = `
                        <h4 class="text-xl font-semibold text-purple-300 mb-2">${set.name}</h4>
                        <p class="text-gray-400 text-sm mb-4">${set.words.length} tá»«</p>
                        <div class="flex flex-col space-y-2">
                            <button class="learn-flashcard-btn px-4 py-2 bg-gradient-to-r from-blue-500 to-cyan-500 text-white font-bold rounded-md hover:from-blue-600 hover:to-cyan-600 transition duration-300 btn-gradient-hover" data-id="${set.id}">Há»c</button>
                            <button class="delete-flashcard-set-btn px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition duration-300 btn-gradient-hover" data-id="${set.id}">XÃ³a</button>
                        </div>
                    `;
                    savedFlashcardGrid.appendChild(card);
                });

                // Attach event listeners to the new buttons
                document.querySelectorAll('.learn-flashcard-btn').forEach(button => {
                    button.addEventListener('click', (event) => {
                        const setId = parseInt(event.target.dataset.id);
                        learnFlashcardSet(setId);
                    });
                });
                document.querySelectorAll('.delete-flashcard-set-btn').forEach(button => {
                    button.addEventListener('click', (event) => {
                        const setId = parseInt(event.target.dataset.id);
                        deleteFlashcardSet(setId);
                    });
                });
            } else {
                noSavedFlashcardsMessage.classList.remove('hidden');
            }
        }

        function resetFlashcardDisplay() {
            shuffledFlashcards = [];
            currentFlashcardIndex = 0;
            isFlipped = false;
            activeFlashcardSetId = null;
            flashcardDisplay.classList.add('hidden'); // Ensure it's hidden when resetting
        }

        function updateFlashcardDisplay() {
            if (shuffledFlashcards.length > 0) {
                const currentCard = shuffledFlashcards[currentFlashcardIndex];
                flashcardWord.textContent = currentCard.word;
                flashcardMeaning.textContent = currentCard.meaning;
                flashcardIPA.textContent = currentCard.ipa;
                flashcardExample.textContent = `"${currentCard.example}"`;
                flashcardCounter.textContent = `Tháº» ${currentFlashcardIndex + 1} / ${shuffledFlashcards.length}`;

                // Set data-word for pronunciation button
                flashcardPronounceBtn.dataset.word = currentCard.word;

                // Reset flip state, then apply if needed for next/prev
                flashcardInner.classList.remove('rotate-y-180');
                isFlipped = false; // Always show front face on new card

                prevFlashcardBtn.disabled = currentFlashcardIndex === 0;
                nextFlashcardBtn.disabled = false; // Always allow next until the very last card
            } else {
                resetFlashcardDisplay();
            }
        }

        flashcardContainer.addEventListener('click', (event) => {
            // Only flip if click is not on the pronounce button
            if (event.target !== flashcardPronounceBtn) {
                isFlipped = !isFlipped;
                if (isFlipped) {
                    flashcardInner.classList.add('rotate-y-180');
                } else {
                    flashcardInner.classList.remove('rotate-y-180');
                }
            }
        });

        flashcardPronounceBtn.addEventListener('click', (event) => {
            event.stopPropagation(); // Prevent flashcard from flipping when pronounce button is clicked
            const wordToSpeak = event.target.dataset.word;
            speakWord(wordToSpeak);
        });


        nextFlashcardBtn.addEventListener('click', () => {
            if (currentFlashcardIndex < shuffledFlashcards.length - 1) {
                // Always flip to front before moving to next card, then move
                flashcardInner.classList.remove('rotate-y-180');
                isFlipped = false;
                // Use a slight delay to allow flip animation to start before content updates
                setTimeout(() => {
                    currentFlashcardIndex++;
                    updateFlashcardDisplay();
                }, 300); // Adjust delay to match CSS transition duration
            } else {
                showCustomAlert('Báº¡n Ä‘Ã£ hoÃ n thÃ nh bá»™ flashcard nÃ y!');
                nextFlashcardBtn.disabled = true; // Disable next button at the end
            }
        });

        prevFlashcardBtn.addEventListener('click', () => {
            if (currentFlashcardIndex > 0) {
                // Always flip to front before moving to prev card, then move
                flashcardInner.classList.remove('rotate-y-180');
                isFlipped = false;
                // Use a slight delay to allow flip animation to start before content updates
                setTimeout(() => {
                    currentFlashcardIndex--;
                    updateFlashcardDisplay();
                }, 300); // Adjust delay to match CSS transition duration
            } else {
                showCustomAlert('Báº¡n Ä‘ang á»Ÿ tháº» Ä‘áº§u tiÃªn.');
                prevFlashcardBtn.disabled = true; // Disable prev button at the beginning
            }
        });

        // --- Newsletter Learning Functions (Card View) ---

        // Function to delete a saved newsletter
        function deleteNewsletter(nlId) {
            savedNewsletters = savedNewsletters.filter(nl => nl.id !== nlId);
            saveData('vocabBoostNewsletters', savedNewsletters);
            renderSavedNewsletters(); // Re-render the grid
            if (activeNewsletterId === nlId) {
                resetNewsletterDisplay(); // Reset display if the active newsletter was deleted
            }
            showCustomAlert('ÄÃ£ xÃ³a báº£n tin.');
        }

        // Function to read a newsletter
        function readNewsletter(nlId) {
            const selectedNewsletter = savedNewsletters.find(nl => s.id === nlId);
            if (selectedNewsletter) {
                activeNewsletterId = nlId; // Set the active newsletter
                
                // Ensure selectedNewsletterContent is visible
                selectedNewsletterContent.classList.remove('hidden'); 
                selectedNewsletterContent.innerHTML = selectedNewsletter.content;
                noSelectedNewsletterContentMessage.classList.add('hidden');
                
                // Display newsletter title and icon
                newsletterTitleDisplay.innerHTML = `${selectedNewsletter.icon} ${selectedNewsletter.name}`;
                newsletterTitleDisplay.classList.remove('hidden'); // Ensure title is visible

                // Hide flashcard sections if they are visible
                flashcardListContainer.classList.remove('is-visible');
                flashcardListContainer.classList.add('hidden');
                flashcardLearningArea.classList.remove('is-visible');
                flashcardLearningArea.classList.add('hidden');

                newsletterListContainer.classList.remove('is-visible');
                newsletterListContainer.classList.add('hidden'); // Hide the list of newsletters immediately after transition starts
                
                setTimeout(() => {
                    newsletterReadingArea.classList.remove('hidden');
                    newsletterReadingArea.classList.add('is-visible'); // Show the reading area with transition
                    // No need to attach event listeners to inline pronounce buttons as they are removed.
                    // The main click listener on selectedNewsletterContent will handle pronunciation.
                }, 500); // Delay matches transition duration
            }
        }

        // Function to go back to the newsletter list
        backToNewsletterListBtn.addEventListener('click', () => {
            newsletterReadingArea.classList.remove('is-visible');
            newsletterReadingArea.classList.add('hidden'); // Hide the reading area immediately after transition starts
            
            setTimeout(() => {
                renderSavedFlashcards(); // Re-render flashcard list to ensure it's visible
                renderSavedNewsletters(); // Re-render newsletter list
                resetNewsletterDisplay(); // Reset display state
            }, 500); // Delay matches transition duration
        });

        function renderSavedNewsletters() {
            savedNewsletterGrid.innerHTML = ''; // Clear current grid
            // Always ensure the list container is visible when this function is called
            newsletterListContainer.classList.remove('hidden');
            newsletterListContainer.classList.add('is-visible');
            // Always ensure the reading area is hidden
            newsletterReadingArea.classList.add('hidden');
            newsletterReadingArea.classList.remove('is-visible');
            newsletterTitleDisplay.classList.add('hidden'); // Hide title when showing list

            if (savedNewsletters.length > 0) {
                noSavedNewslettersMessage.classList.add('hidden');
                savedNewsletters.forEach(nl => {
                    const card = document.createElement('div');
                    card.className = 'bg-gray-800 p-4 rounded-lg shadow-md flex flex-col justify-between';
                    card.innerHTML = `
                        <h4 class="text-xl font-semibold text-purple-300 mb-2 flex items-center">${nl.icon} <span class="ml-2">${nl.name}</span></h4>
                        <div class="flex flex-col space-y-2">
                            <button class="read-newsletter-btn px-4 py-2 bg-gradient-to-r from-blue-500 to-cyan-500 text-white font-bold rounded-md hover:from-blue-600 hover:to-cyan-600 transition duration-300 btn-gradient-hover" data-id="${nl.id}">Äá»c</button>
                            <button class="delete-newsletter-btn px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition duration-300 btn-gradient-hover" data-id="${nl.id}">XÃ³a</button>
                        </div>
                    `;
                    savedNewsletterGrid.appendChild(card);
                });

                // Attach event listeners to the new buttons
                document.querySelectorAll('.read-newsletter-btn').forEach(button => {
                    button.addEventListener('click', (event) => {
                        const nlId = parseInt(event.target.dataset.id);
                        readNewsletter(nlId);
                    });
                });
                document.querySelectorAll('.delete-newsletter-btn').forEach(button => {
                    button.addEventListener('click', (event) => {
                        const nlId = parseInt(event.target.dataset.id);
                        deleteNewsletter(nlId);
                    });
                });
            } else {
                noSavedNewslettersMessage.classList.remove('hidden');
            }
        }

        function resetNewsletterDisplay() {
            activeNewsletterId = null;
            selectedNewsletterContent.innerHTML = '';
            selectedNewsletterContent.classList.add('hidden'); // Ensure it's hidden when resetting
            noSelectedNewsletterContentMessage.classList.remove('hidden');
            newsletterTitleDisplay.innerHTML = ''; // Clear title
            newsletterTitleDisplay.classList.add('hidden'); // Hide title
        }

        // Function to handle word clicks (used by both newsletterContentDiv and selectedNewsletterContent)
        function handleWordClick(event) {
            const target = event.target;
            // Ensure click is on the highlighted word itself
            if (target.classList.contains('highlighted-word')) {
                const meaning = target.dataset.meaning;
                const ipa = target.dataset.ipa;
                // Add fallback for partOfSpeech if it's empty or undefined
                const partOfSpeech = target.dataset.partOfSpeech || '';
                const wordToSpeak = target.textContent;

                speakWord(wordToSpeak);

                popupMeaning.textContent = meaning;
                popupIPA.textContent = ipa;
                // Only display partOfSpeech if it exists
                popupPartOfSpeech.textContent = partOfSpeech ? `(${partOfSpeech})` : '';

                wordPopup.classList.remove('hidden');
                wordPopup.classList.add('is-visible');
                
                // Get dimensions after making it visible
                const popupWidth = wordPopup.offsetWidth; 
                const popupHeight = wordPopup.offsetHeight;

                const targetRect = target.getBoundingClientRect();
                const mainRect = main.getBoundingClientRect();

                // Calculate horizontal position relative to the main content area
                let popupLeft = (targetRect.left + (targetRect.width / 2)) - (popupWidth / 2) - mainRect.left;
                
                // Adjust for left boundary of main content area
                if (popupLeft < 0) {
                    popupLeft = 0;
                }
                // Adjust for right boundary of main content area
                if (popupLeft + popupWidth > mainRect.width) {
                    popupLeft = mainRect.width - popupWidth;
                }

                // Calculate vertical position relative to the main content area
                let popupTop;
                const padding = 5; // Padding between word and popup

                // Check if there's enough space above the word (relative to viewport)
                const spaceAboveViewport = targetRect.top - popupHeight - padding;
                // Check if there's enough space below the word (relative to viewport)
                const spaceBelowViewport = window.innerHeight - targetRect.bottom - popupHeight - padding;

                if (spaceAboveViewport >= 0) { // Enough space above in viewport
                    popupTop = targetRect.top - popupHeight - padding - mainRect.top;
                } else if (spaceBelowViewport >= 0) { // Enough space below in viewport
                    popupTop = targetRect.bottom + padding - mainRect.top;
                } else { // Not enough space either way, prioritize placing below
                    popupTop = targetRect.bottom + padding - mainRect.top;
                    // Further adjust if it still goes off the bottom of mainRect
                    if (popupTop + popupHeight > mainRect.height) {
                        popupTop = mainRect.height - popupHeight;
                    }
                    // If it still goes off the top of mainRect (e.g., mainRect is very short)
                    if (popupTop < 0) {
                        popupTop = 0;
                    }
                }

                // Apply positioning to the popup
                wordPopup.style.left = `${popupLeft}px`;
                wordPopup.style.top = `${popupTop}px`;
                
                target.classList.add('clicked-effect');
                setTimeout(() => {
                    target.classList.remove('clicked-effect');
                }, 300);
            } else {
                wordPopup.classList.remove('is-visible');
                setTimeout(() => {
                    wordPopup.classList.add('hidden');
                }, 200);
            }
        }

        // Event listeners for clicking on highlighted words in newsletter
        // Apply to both the content div in "create" tab and "review" tab
        newsletterContentDiv.addEventListener('click', handleWordClick); // New: for create tab
        selectedNewsletterContent.addEventListener('click', handleWordClick); // Existing: for review tab

        // Hide popup when clicking anywhere else on the document
        document.addEventListener('click', (event) => {
            // Check if the click was not inside the popup AND not on a highlighted word
            if (!wordPopup.contains(event.target) && !event.target.classList.contains('highlighted-word') && wordPopup.classList.contains('is-visible')) {
                wordPopup.classList.remove('is-visible');
                setTimeout(() => {
                    wordPopup.classList.add('hidden');
                }, 200);
            }
        });


        // --- Tab Switching Event Listeners ---
        createTabBtn.addEventListener('click', () => showTab('create'));
        reviewTabBtn.addEventListener('click', () => showTab('review'));

        // --- Enter Key Press Listeners ---
        vocabTopicInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault(); // Prevent default form submission
                generateVocabBtn.click();
            }
        });

        newsletterTopicInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault(); // Prevent default form submission
                generateNewsletterBtn.click();
            }
        });

    </script>
</body>
</html>
